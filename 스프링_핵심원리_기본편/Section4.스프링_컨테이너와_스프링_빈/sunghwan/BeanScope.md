# Bean Scope

## 1. bean scope

스프링 프레임 워크의 핵심은 스프링이 개발자를 대신해서 빈의 생명주기를 관리해주고, 애플리케이션에서 빈이 필요한 시점에 스프링이 빈을 주입해 준다는 것이다.

애플리케이션 구동 시 JVM 안에서 스프링이 빈마다 하나의 객체를 생성한다는 뜻.

그래서 우리는 스프링을 통해서 빈을 제공받으면 언제나 주입받은 빈은 동일한 객체라는 가정하에서 개발을 한다.

싱글톤의 경우, 동일한 빈이 재사용될 때 새롭게 객체를 생성할 필요가 없고, 객체를 생성하지 않기 때문에 GC의 부담도 사라진다. 그러나 싱글톤으로만 처리할 수 없거나, 처리해서는 안되는 객체들의 경우를 고려하여 여러 종류의 scope 설정을 제공한다.



## 2. Bean Scope의 종류

| Scope          | Description                                                  |
| -------------- | ------------------------------------------------------------ |
| singleton      | 하나의 Bean 정의에 대해서 Spring IoC Container 내에 단 하나의 객체만 존재한다. |
| prototype      | 하나의 Bean 정의에 대해서 다수의 객체가 존재할 수 있다.      |
| request        | 하나의 Bean 정의에 대해서 하나의 HTTP request의 생명주기 안에 단 하나의 객체만 존재한다; 즉, 각각의 HTTP request는 자신만의 객체를 가진다. Web-aware Spring ApplicationContext 안에서만 유효하다. |
| session        | 하나의 Bean 정의에 대해서 하나의 HTTP Session의 생명주기 안에 단 하나의 객체만 존재한다. Web-aware Spring ApplicationContext 안에서만 유효하다. |
| global session | 하나의 Bean 정의에 대해서 하나의 global HTTP Session의 생명주기 안에 단 하나의 객체만 존재한다. 일반적으로 portlet context 안에서 유효하다. Web-aware Spring ApplicationContext 안에서만 유효하다. |



## 3. 싱글톤과 비싱글톤의 차이

스프링을 쓰면서 빈을 prototype 등의 비싱글톤 타입으로 관리해서 사용하는 경우는 많지 않다고 한다. 그러나 상황에 따라서 싱글톤으로만 빈을 관리하기 어려운 경우가 존재한다.

"상태를 가진 객체"가 이에 해당할 수 있다.



**싱글톤으로 적합한 객체**

1. **상태가 없는 공유 객체**: 상태를 가지고 있지 않은 객체는 동기화 비용이 없다. 따라서 매번 이 객체를 참조하는 곳에서 새로운 객체를 생성할 이유가 없다.
2. **읽기용으로만 상태를 가진 공유 객체**: 1번과 유사하게 상태를 가지고 있으나 읽기 전용이므로 여전히 동기화 비용이 들지 않는다. 매 요청마다 새로운 객체 생성할 필요가 없다.
3. **공유가 필요한 상태를 지닌 공유 객체**: 객체 간의 반드시 공유해야 할 상태를 지닌 객체가 하나 있다면,  이 경우에는 해당 상태의 쓰기를 가능한 동기화 할 경우 싱글톤도 적합하다.
4. **쓰기가 가능한 상태를 지니면서도 사용빈도가 매우 높은 객체**: 애플리케이션 안에서 정말로 사용빈도가 높다면, 쓰기 접근에 대한 동기화 비용을 감안하고서라도 싱글톤을 고려할만하다. 이 방법은 1. 장시간에 걸쳐 매우 많은 객체가 생성될 때, 2. 해당 객체가 매우 작은 양의 쓰기상태를 가지고 있을 때, 3. 객체 생성비용이 매우 클 때에 유용한 선택이 될 수 있다.

> 즉, **상태가 없거나,**
>
> **상태가 있긴 한데 항상 같은 값이거나,**
>
> **상태가 있고 바뀔 가능성도 있지만 이를 항상 공유할 목적이거나,**
>
> **사용 빈도가 너무 높아서 동기화 비용을 감수할 경우**



**비싱글톤으로 적합한 객체**

1. 쓰기가 가능한 상태를 지닌 객체: 쓰기가 가능한 상태가 많아서 동기화 비용이 객체 생성 비용보다 크다면 싱글톤으로 적합하지 않다.
2. 상태가 노출되지 않은 객체: 일부 제한적인 경우, 내부 상태를 외부에 노출하지 않는 빈을 참조하여 다른 의존객체와는 독립적으로 작업을 수행하는 의존 객체가 있다면 싱글톤보다 비싱글톤 객체를 사용하는 것이 더 나을 수 있다.



### 싱글톤과 비싱글톤을 구분해서 빈을 선언하는 기준은?

1. 수정 가능한 상태에 따라 동기화 비용
2. 객체 생성 비용간의 트레이드 오프



> 수정이 가능한 상태의 객체는 일반적인 방법으로 new ~~~() 와 같이 애플리케이션 안에서 직접 객체를 생성하면 되지 않을까?

### 싱글톤으로 선언하여 스프링에게 관리를 맡긴 빈과 개발자가 직접 관리할 객체를 구분하는 기준은?

비싱글톤 객체가 스프링에서 관리하는 빈을 참조하는 경우에는 프로토타입으로 선언하는 것도 의미가 있을 수 있지만, 그렇지 않은 일반적인 객체를 굳이 빈으로 등록할 필요는 없을 수 있다.